import 'dart:math';

import '../../utility/spacedPrint.dart';

// Iterable.generate | Parameterized Named Constructor

//   - a parameterized named constructor of Iterable class
//   - as the identity (name) implies it is a genterator of an Iterable
//   - Iterable.generate has two parameters, the first is the desired lenth of the Iterable
//     the second is a parameterized generator callback that requires a positional integer parameter
//   - the callback can be a pointer it a callback or a lambda function

// define shape of the parameterized generator anonymous callback
typedef generatorCallback<E> = E Function(int index);

// declare variable as a generatorCallback then initalize it with a lambda function
final generatorCallback<int> intGeneratorCallback = (int index) => index * 2;

final generatorCallback<int> powerCallback = (int index) => pow(index, 2).toInt();

final generatorCallback<String> qouteCallback =
    (int index) => 'Begin, to begin is half of the work; Let half still remain; Again begin this and thou will have finished.';
void main() {
  // Generates an Iterable of length 6 using Iterable.generate(length, generator)
  final Iterable<int> generatedIterable = Iterable.generate(
    6,
    intGeneratorCallback,
  );

  // Generates an Iterable of length 6 using [0,1,2,3,...,n].map(generator) (Literal.map)
  final Iterable<int> generatedIterableFromListLiteral = [0, 1, 2, 3, 4, 5].map(
    powerCallback,
  );

  final Iterable<String> generatedIterableFromSetLiteral = {0, 1, 2, 3}.map(
    qouteCallback,
  );

  spacedPrint('Iterable generated by Iterable.generate: $generatedIterable', prefix_space: true);
  spacedPrint('Iterable generated by List literal: $generatedIterableFromListLiteral', prefix_space: true);
  spacedPrint('Iterable generated by Set literal: $generatedIterableFromSetLiteral', prefix_space: true);
}
// Using literal.map(anonymousFunction) | Set and List Literals

//   - you do not have to do utilize the elements of a collection
//     in body of a callback passed to the map function
//   - you only need to take in the element in the callback

// Generating an Iterable with Iterable.generate vs [].map(anonymousFunction) or {}.map(anonymousFunction) (Literal.map)

//   - There is less boiler plate code when using Iterable.generate(n, anonymousFunction)
//   - as you do not have to explicitly define the number of elements
//     which you would have to do if using a Literal
//   - the number of elements are passed in as an argument to Iterable.generate